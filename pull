#!/bin/rc -e

rfork en

nl='
'

fn update{
	branch=$1
	upstream=$2
	url=$3
	dir=$4

	fetch=`"{git/fetch  -b $branch -u $upstream $url |[2]  tr '\x0d' '\x0a'}
	st=$status
	if(! ~ $st ''){
		echo fetch failed: $st
		exit $st
	}	
	echo $"fetch | awk '
	/^remote/{
		if($2=="HEAD")
			next
		ref=$2
		hash=$3
		gsub("^refs/heads", "refs/remotes/'$upstream'", ref)
		outfile = ".git/"ref
		system("mkdir -p `{basename -d "outfile"}");
		print hash > outfile;
		close(outfile);
	}
	'
}

fn usage{
	echo usage: $0 '[-a] [-u upstream] [-b branch]
	-u up:	pull from upstream "up" (default: origin)
	-f:	fetch without updating working copy' >[1=2]
	exit usage
}

branch=`{awk '$1=="branch"{print $2}' < /mnt/git/ctl}
remote=()
checkout='true'
upstream=origin

if(! cd `{git/conf -r}){
	echo 'not in git repository' >[1=2]
	exit notgit
}
git/fs

while(~ $1 -*){
	switch($1){
	case -u
		upstream=SOMEONE
		remote=$2
		shift
	case -b
		branch=$2
		shift
	case -f
		checkout=()
	case *
		usage
	}
	shift
}
if(! ~ $#* 0)
	usage

if(~ $#remote 0)
	remote=`{git/conf 'remote "'$upstream'".url'}
if(~ $#remote 0){
	echo 'no idea from where to pull'
	exit upstream
}

update $branch $upstream $remote
if (~ $#checkout 0)
	exit

local=`{git/branch}
remote=`{git/branch | sed 's@^(refs/)?heads@remotes/'$upstream'@'}

# we have local commits, but the remote hasn't changed.
# in this case, we want to keep the local commits untouched.
if(~ `{git/query HEAD $remote @} `{git/query $remote}){
	echo up to date >[1=2]
	exit
}
# The remote repository and our HEAD have diverged: we
# need to merge.
if(! ~ `{git/query HEAD $remote @} `{git/query HEAD}){
	echo git/merge $remote '# diverged' >[1=2]
	exit merge
}

# The remote is directly ahead of the local, and we have
# no local commits that need merging.
git/branch -u -b $remote $local
